{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>dj-tracker</code> is an app that tracks your queries to help detecting some possible performance optimisations listed in Database access optimization.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Detailed field usage of model instances</li> <li>Report unused fields in a model instance and provides hints on when to use <code>.defer</code> and <code>.only</code></li> <li>Report model instance attributes access and provides hints on when to use <code>.values</code> or <code>.values_list</code></li> <li>Report cache hits and provides hints on when to use <code>iterator</code></li> <li>Provides hints on when to use <code>.count</code>, <code>.contains</code>, <code>.exists</code></li> <li>Detect N+1 queries</li> <li>Detect when a deferred field is loaded</li> <li>and many more insights into your queries with minimized overhead....</li> </ul>"},{"location":"#demo","title":"Demo","text":"<p>You can try <code>dj-tracker</code> with the bakerydemo on the demo app.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python: <code>&gt;=3.8</code></li> <li>Django: <code>&gt;=3.2</code></li> <li>django-filter</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>Check out the installation steps if you want to get started quickly or the tutorial to see a concrete example of <code>dj-tracker</code> usage.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>All documentation is in the \"docs\" directory and online at https://tijani-dia.github.io/dj-tracker/</p>"},{"location":"#development-phase-contributing","title":"Development phase - Contributing","text":"<p><code>dj-tracker</code> is in alpha phase.</p> <p>You can help a lot by reporting bugs you'll encounter. Feature requests, PRs or/and any feedback are also welcome.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#dj_tracker-settings","title":"<code>dj_tracker</code> settings","text":"<p>All <code>dj_tracker</code> settings must be defined in a dictionary named <code>DJ_TRACKER</code> in your project's settings.</p>"},{"location":"configuration/#apps_to_exclude","title":"<code>APPS_TO_EXCLUDE</code>","text":"<p>By default, <code>dj_tracker</code> tracks all models in all apps except from <code>dj_tracker</code> itself. You can add additionnal apps to exclude with this setting:</p> <pre><code>DJ_TRACKER = {\n    \"APPS_TO_EXCLUDE\": {\"third-party-app\", \"test-app\"},\n}\n</code></pre>"},{"location":"configuration/#ignore_paths","title":"<code>IGNORE_PATHS</code>","text":"<p>Requests to URLs containing any component defined in this setting aren't tracked.</p> <pre><code>DJ_TRACKER = {\n    \"IGNORE_PATHS\": {\"/favicon.ico\", \"/static/\"}\n}\n</code></pre>"},{"location":"configuration/#ignore_modules","title":"<code>IGNORE_MODULES</code>","text":"<p>A set of file or module names to ignore in tracebacks.</p> <pre><code>DJ_TRACKER = {\n    \"IGNORE_MODULES\": {\"whitenoise/\", \"sentry_sdk/\"}\n}\n</code></pre>"},{"location":"configuration/#collection_interval","title":"<code>COLLECTION_INTERVAL</code>","text":"<p>Interval at which the <code>Collector</code> should save trackings. The default value is <code>5s</code>.</p> <pre><code>DJ_TRACKER = {\n    \"COLLECTION_INTERVAL\": 1\n}\n</code></pre>"},{"location":"configuration/#field_descriptors","title":"<code>FIELD_DESCRIPTORS</code>","text":"<p>If your program uses custom field descriptors, you can specify the path to the descriptor to use when tracking fields of that type. It can simply be the built-in <code>EditableFieldDescriptor</code> but can also be any subclass of <code>FieldDescriptor</code> provided that it's a data descriptor (i.e implements the <code>__set__</code> method).</p> <p>For example, Wagtail defines a <code>Creator</code> descriptor for its StreamField that can be tracked as follows:</p> <pre><code>DJ_TRACKER = {\n    \"FIELD_DESCRIPTORS\": {\n        \"Creator\": \"dj_tracker.field_descriptors.EditableFieldDescriptor\"\n    }\n}\n</code></pre>"},{"location":"configuration/#track_attributes_accessed","title":"<code>TRACK_ATTRIBUTES_ACCESSED</code>","text":"<p><code>dj-tracker</code> patches the <code>__getattribute__</code> method on tracked models to provide hints on using <code>values</code> or <code>values_list</code> when it detects that no model attribute or method was accessed except the fields fetched from the database. This add an overhead to every attribute access. To disable this feature, set this setting to <code>False</code>. It's enabled by default.</p> <pre><code>DJ_TRACKER = {\n    \"TRACK_ATTRIBUTES_ACCESSED\": False\n}\n</code></pre>"},{"location":"configuration/#trackings-database","title":"<code>trackings</code> database","text":"<p><code>dj_tracker</code> gives the possibility to have a separate table to store trackings. This can be useful if you intend to run it with your tests, to track model instances in different databases (<code>staging</code>, <code>production</code>, ...) but also to monitor your queries between releases.</p>"},{"location":"configuration/#add-the-database","title":"Add the database","text":"<p>Add a <code>trackings</code> entry to your <code>DATABASES</code> settings:</p> <pre><code>DATABASES = {\n    \"default\": ...,\n    \"trackings\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": str(BASE_DIR / \"trackings\"),\n    },\n}\n</code></pre> <p>The examples uses a <code>sqlite</code> database but you can use any engine.</p>"},{"location":"configuration/#add-the-database-router","title":"Add the database router","text":"<p>Add the following to the list of <code>DATABASE_ROUTERS</code>:</p> <pre><code>DATABASE_ROUTERS = [\n    ...,\n    \"dj_tracker.db_router.DjTrackerRouter\",\n]\n</code></pre>"},{"location":"configuration/#run-migrations","title":"Run migrations","text":"<p>Run the migrations for the <code>trackings</code> database:</p> <pre><code>python manage.py migrate dj_tracker --database=trackings\n</code></pre>"},{"location":"dashboard/","title":"Dasboard","text":"<p>This page gives an overview of the <code>dj-tracker</code> dashboard structure.</p>"},{"location":"dashboard/#dashboard","title":"Dashboard","text":"<p>The trackings dashboard is available at <code>/dj-tracker/</code>. It shows the latest and most visited URLs along with various insights into your queries:</p> <p></p>"},{"location":"dashboard/#requests","title":"Requests","text":"<p>The <code>/dj-tracker/requests/</code> endpoint lists all requests tracked. It allows sorting them by date, path or number of occurrences but also filtering them to only show those where a N+1 situation was detected.</p> <p></p> <p>When you click in one of the requests shown in the dashboard, it will redirect to a page showing the different query groups for that request.</p> <p></p>"},{"location":"dashboard/#query-groups","title":"Query groups","text":"<p>A query group, as the name suggests, is a group of queries that occur together; generally inside a full request-response cycle.</p> <p>The list of all query groups is available at <code>/dj-tracker/query-groups/</code>. It allows sorting them by date, number of queries or number of occurrences. Similar to the requests page, it also allows filtering query groups to only show those where a N+1 situation was detected.</p> <p></p> <p>Clicking on one of the query groups displayed will show all the queries in that group with some statistics associated to them. It also gives the ability to only show duplicate queries or queries that induced other ones (<code>Related queries</code>).</p> <p></p>"},{"location":"dashboard/#queries","title":"Queries","text":"<p>All queries tracked are available at <code>/dj-tracker/queries/</code>. It allows sorting them by average duration, number of occurrences or number of instances. The list can be filtered by model or query type.</p> <p></p> <p>Clicking on of the queries will display various information about a query: the traceback, the SQL generated, fields usage but also hints on how to improve the query:</p> <p></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-the-package","title":"Install the package","text":"<p>Install <code>django-trackings</code> from PyPi:</p> <pre><code>pip install django-trackings\n</code></pre>"},{"location":"installation/#add-dj_tracker-to-installed_apps","title":"Add <code>dj_tracker</code> to <code>INSTALLED_APPS</code>","text":"<p>Add <code>dj_tracker</code> to your <code>INSTALLED_APPS</code> in your settings:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    \"dj_tracker\",\n    ...\n]\n</code></pre>"},{"location":"installation/#add-dj_tracker-middleware","title":"Add <code>dj_tracker</code> middleware","text":"<p>Add <code>DjTrackerMiddleware</code> to the <code>MIDDLEWARE</code> list in your project's settings:</p> <pre><code>MIDDLEWARE = [\n    \"dj_tracker.middleware.DjTrackerMiddleware\",\n    ...\n]\n</code></pre>"},{"location":"installation/#add-dj_tracker-urls","title":"Add <code>dj_tracker</code> URLs","text":"<p>Add the following to your <code>urls.py</code> file:</p> <pre><code>from dj_tracker.urls import urlpatterns as dj_tracker_urls\n\n\nurlpatterns = [\n    ...\n    path(\"dj-tracker/\", include(dj_tracker_urls)),\n    ...\n]\n</code></pre>"},{"location":"installation/#run-migrations","title":"Run migrations","text":"<p>Run the migrations for the <code>dj_tracker</code> app:</p> <pre><code>python manage.py migrate dj_tracker\n</code></pre>"},{"location":"installation/#there-we-go","title":"There we go","text":"<p>Your Django models are now ready to be tracked!</p> <p>Run the <code>runserver</code> command with the <code>--noreload</code> option (important) and your trackings will be available at <code>/dj-tracker/</code>.</p> <p>Have a look at the Tutorial page to learn more about how to use <code>dj_tracker</code> to optimise your queries or see the configuration options available.</p>"},{"location":"tutorial/detect_and_resolve_related_queries/","title":"Detect and resolve related queries","text":"<p>In the previous section, we set up a simple view and noticed, after some profiling, that it's particularly slow.</p>"},{"location":"tutorial/detect_and_resolve_related_queries/#detecting-related-queries","title":"Detecting related queries","text":"<p>If you didn't see them in the previous step, here are the informations that <code>dj-tracker</code> shows for our books query:</p> <p></p> <p>Apart from the various information on the query itself, we can see that 4000 queries were made via the <code>author</code> and <code>category</code> fields for our 4000 book instances. In other terms, we're making 2 additional queries for each <code>Book</code> instance of our initial queryset a.k.a (2)N + 1. This is very inefficient and the number of queries will keep increasing as we add more <code>Book</code> instances.</p>"},{"location":"tutorial/detect_and_resolve_related_queries/#resolving-related-queries","title":"Resolving related queries","text":"<p>In our situation, we can use the <code>select_related</code> method to fetch all books' authors and categories in a single query.</p> <p>Let's update our view as follows:</p> <pre><code>def books_list(request):\n    books = Book.objects.select_related(\"author\", \"category\")\n    return render(request, \"books.html\", {\"books\": books})\n</code></pre> <p>and run our benchmark:</p> <pre><code>Time in ms (10 calls) - Min: 214.51, Max: 292.08, Avg: 251.26\n\nMemory - size in KiB (10 calls) - Min: 35250.04, Max: 35683.38, Avg: 35521.38\nMemory - peak in KiB (10 calls) - Min: 38213.27, Max: 38647.72, Avg: 38481.93\n</code></pre> <p>Our view renders in just 250ms now! That's around 16x speedup compared to our previous version in terms of speed gains. We can also notice that this version uses 5Mb less memory.</p> <p>Refer to the Django documentation for more information on <code>select_related</code> and <code>prefetch_related</code>.</p>"},{"location":"tutorial/detect_and_resolve_related_queries/#summary","title":"Summary","text":"<p>In the <code>dj-tracker</code> dashboard, you can see the latest N+1 situations that were detected.</p> <p>You can also filter requests by the ones where N+1 queries were detected.</p> <p>In the query group view, all queries that come from the same field in a queryset are grouped together along with the number of times it happened.</p> <p>You can then visually tell if you have a N+1 when the number of instances in an initial query is equal to the number of queries that come from a field of the corresponding model.</p> <p>Depending on the type of the field, you can either use <code>select_related</code> or <code>prefetch_related</code> to avoid the related queries.</p>"},{"location":"tutorial/detect_and_resolve_related_queries/#how-it-looks","title":"How it looks?","text":"<p>Here is how the dashboard looks with our new changes:</p> <p>You can see that we no longer have the <code>Related</code> section but the number of instances shown is now 12000 representing <code>4000 Book + 4000 Author + 4000 Category</code>.</p> <p></p> <p>We can click on the query id to have even more information about it (SQL generated, traceback, fields usage...).</p> <p>The next steps will show how we can use those informations to improve our query.</p>"},{"location":"tutorial/final_notes/","title":"Final notes","text":"<p>We started with a very slow (1735ms) and memory-consuming (19.5MB) view, applied common optimisations for querysets using the hints and insights <code>dj-tracker</code> provided us with and finished with a view that performs reasonably (48ms and 0.15MB).</p> <p>We can also keep track of the view's performance over time in the <code>dj-tracker</code> dashboard (e.g when we decide that we also want to show a book's summary).</p>"},{"location":"tutorial/final_notes/#misc","title":"Misc","text":"<ul> <li> <p><code>dj-tracker</code> can automatically provide these additional hints: <code>Use .count</code>, <code>Use .exists</code>, <code>Use .contains</code></p> </li> <li> <p>You may not necesarily be able to apply all optimisations we did for our books query, however in many cases, you'll be able to apply some of them.</p> </li> <li> <p>Use the <code>.iterator</code> optimisation with caution, ignoring the hint shown in the queryset page if necessary.</p> </li> </ul>"},{"location":"tutorial/setup/","title":"Tutorial","text":"<p>This tutorial shows how you can use <code>dj-tracker</code> to monitor and improve your queries.</p> <p>We'll take the example of building a page that shows all books of a library.</p> <p>The source code is available in the <code>tutorial</code> directory. The README contains instructions to set up the project locally. However, it isn't required and you can just follow along to understand how you might use it in your own project.</p>"},{"location":"tutorial/setup/#models","title":"Models","text":"<p>We'll work with the following models:</p> <pre><code>from django.db import models\n\n\nclass Category(models.Model):\n    name = models.CharField(max_length=64)\n\n\nclass Author(models.Model):\n    first_name = models.CharField(max_length=64)\n    last_name = models.CharField(max_length=64)\n    date_of_birth = models.DateTimeField()\n    date_of_death = models.DateTimeField(null=True, blank=True)\n    biography = models.TextField()\n\n\nclass Book(models.Model):\n    title = models.CharField(max_length=255)\n    summary = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\n</code></pre> <p>We also define some factories to build <code>Book</code> instances to work with:</p> <pre><code>import factory\n\nfrom .models import Author, Book, Category\n\n\nclass CategoryFactory(factory.django.DjangoModelFactory):\n    class Meta:\n        model = Category\n\n    name = factory.Faker(\"word\")\n\n\nclass AuthorFactory(factory.django.DjangoModelFactory):\n    class Meta:\n        model = Author\n\n    first_name = factory.Faker(\"first_name\")\n    last_name = factory.Faker(\"last_name\")\n    date_of_birth = factory.Faker(\"date_of_birth\")\n    date_of_death = factory.Faker(\"date_time_this_century\")\n    biography = factory.Faker(\"text\", max_nb_chars=5000)\n\n\nclass BookFactory(factory.django.DjangoModelFactory):\n    class Meta:\n        model = Book\n\n    title = factory.Faker(\"sentence\")\n    summary = factory.Faker(\"text\", max_nb_chars=2500)\n    author = factory.SubFactory(AuthorFactory)\n    category = factory.SubFactory(CategoryFactory)\n\n\ncreate_books = BookFactory.create_batch\n</code></pre> <p>Keep in mind how we set a large content for the <code>summary</code> and <code>biography</code> fields.</p> <p>In a terminal, we create 4000 books to work with:</p> <pre><code>python manage.py shell -c  \"from app.factories import create_books; create_books(4000)\"\n</code></pre>"},{"location":"tutorial/setup/#view-template","title":"View - Template","text":"<p>The view that shows all books in the database is defined as follow:</p> <pre><code>from django.shortcuts import render\n\nfrom .models import Book\n\n\ndef books_list(request):\n    books = Book.objects.all()\n    return render(request, \"books.html\", {\"books\": books})\n</code></pre> <p>and this is the corresponding template:</p> <pre><code>{% for book in books %}\n&lt;h4&gt;{{ book.title }}&lt;/h4&gt;\n&lt;dl&gt;\n  &lt;dt&gt;Author&lt;/dt&gt;\n  &lt;dd&gt;{{ book.author.first_name }} {{ book.author.last_name }}&lt;/dd&gt;\n\n  &lt;dt&gt;Category&lt;/dt&gt;\n  &lt;dd&gt;{{ book.category.name }}&lt;/dd&gt;\n&lt;/dl&gt;\n{% endfor %}\n</code></pre>"},{"location":"tutorial/setup/#urls","title":"URLs","text":"<p>To see how our view performs, we have additional <code>/time/</code> and <code>/memory/</code> endpoints to track timings and memory usage:</p> <pre><code>from django.urls import path\n\nfrom .profile import MemoryProfiler, TimeProfiler\nfrom .views import books_list\n\nurlpatterns = [\n    path(\"\", books_list),\n    path(\"time/\", TimeProfiler(books_list)),\n    path(\"memory/\", MemoryProfiler(books_list)),\n]\n</code></pre>"},{"location":"tutorial/setup/#profiling","title":"Profiling","text":"<p>We'll use the following methodology to profile the view:</p> <ul> <li>Make 10 requests sequentially to the <code>/time/</code> endpoint</li> <li>Make 10 requests sequentially to the <code>/memory/</code> endpoint</li> <li>Make 1 request to the books endpoint with <code>dj-tracker</code> running</li> </ul> <p>We run each of these steps in a new process to have consistent results.</p> <p>Let's now run the first benchmark to see how our view performs:</p> <pre><code>Time in ms (10 calls) - Min: 3517.68, Max: 4557.71, Avg: 3964.97\n\nMemory - size in KiB (10 calls) - Min: 38986.07, Max: 39572.61, Avg: 39151.99\nMemory - peak in KiB (10 calls) - Min: 41946.51, Max: 42529.80, Avg: 42112.31\n</code></pre> <p>Our view takes 4s to render and uses around 40Mb in average (in my machine)!</p>"},{"location":"tutorial/setup/#dj-tracker-dashboard","title":"<code>dj-tracker</code> dashboard","text":"<p>Here is how the <code>dj-tracker</code> dashboard looks like at this point:</p> <p>In the following steps, we'll take a closer look at the informations <code>dj-tracker</code> gives us to see how we can improve our view.</p>"},{"location":"tutorial/use_iterator/","title":"<code>iterator</code> usage","text":"<p>From the Django docs:</p> <p>When you have a lot of objects, the caching behavior of the QuerySet can cause a large amount of memory to be used. In this case, iterator() may help.</p> <p><code>dj-tracker</code> can show how effective the caching behavior of QuerySets is via the <code>cache_hits</code> field:</p> <p></p> <p><code>dj-tracker</code> will show a <code>Use .iterator</code> hint when the number of cache hits is equal to 1 (i.e when we use instances of a queryset only once).</p>"},{"location":"tutorial/use_iterator/#example","title":"Example","text":"<p>In our example, we're using every book instance once: when we render them in the template. However, Django's for template tag checks the length of the iterable passed or converts it into a list if it doesn't implement the <code>__len__</code> method. This means that the cache hits will at least be 2 if we use the <code>{% for ... %}</code> templatetag: one cache hit to get the length and another one for when we actually iterate over the sequence. That's the reason why <code>dj-tracker</code> doesn't show this hint for our queryset.</p> <p>For the sake of this tutorial, we'll use a custom templatetag which behaves similarly to the <code>for</code> tag, except that it doesn't check the length nor converts the iterable passed into a list beforehand. By the way, the queryset's cache is hit once. We update our template as follows:</p> <pre><code>{% load iterate_tags %}\n\n{% iterate book in books %}\n&lt;h4&gt;{{ book.title }}&lt;/h4&gt;\n&lt;dl&gt;\n  &lt;dt&gt;Author&lt;/dt&gt;\n  &lt;dd&gt;{{ book.author__first_name }} {{ book.author__last_name }}&lt;/dd&gt;\n\n  &lt;dt&gt;Category&lt;/dt&gt;\n  &lt;dd&gt;{{ book.category__name }}&lt;/dd&gt;\n&lt;/dl&gt;\n{% enditerate %}\n</code></pre> <p>If we go to the books endpoint with <code>dj-tracker</code> running, we'll now see the <code>Use .iterator</code> hint:</p> <p></p>"},{"location":"tutorial/use_iterator/#view","title":"View","text":"<p>Let's go ahead and update our view to use <code>.iterator</code>:</p> <pre><code>def books_list(request):\n    books = Book.objects.values(\n        \"title\",\n        \"category__name\",\n        \"author__first_name\",\n        \"author__last_name\",\n    ).iterator()\n    return render(request, \"books.html\", {\"books\": books})\n</code></pre> <p>and run the benchmarks:</p> <pre><code>Time in ms (10 calls) - Min: 96.63, Max: 133.22, Avg: 110.21\n\nMemory - size in KiB (10 calls) - Min: 578.33, Max: 848.29, Avg: 607.47\nMemory - peak in KiB (10 calls) - Min: 3544.61, Max: 3820.03, Avg: 3575.13\n</code></pre> <p>Our timings haven't changed much but we are now only using 0.6MB in average (the previous average was 3.4MB). That's a 4x memory improvement without trading off too much speed.</p>"},{"location":"tutorial/use_iterator/#summary","title":"Summary","text":"<p><code>dj-tracker</code> can show effective a queryset's cache is and give hints on when to use the <code>iterator</code> method.</p> <p>Since the hint is solely based on the cache hits, it may be up to you to figure out what happens when you think that your instances should only be used once but they aren't. Also, it's worth taking into consideration that the <code>.iterator</code> optimisation is mostly useful when you have a lot of objects as it can consume more time and memory when that is not the case.</p>"},{"location":"tutorial/use_only_or_defer/","title":"<code>only</code>/<code>defer</code> usage","text":"<p>The Field Stats section of a query page shows how much time each field has been accessed for each instance in a queryset.</p> <p>It shows a main table corresponding to the main model of a queryset and in cases where we have other instances related to the main model, it shows a separate table for each related model.</p> <p>This is what the field stats look like for our books query:</p> <p></p> <p>We can see that only the <code>author</code>, <code>category</code> and <code>title</code> fields were accessed for the <code>Book</code> instances. Similarly, only the <code>first_name</code> and <code>last_name</code> were accessed for the <code>Author</code> instances and <code>name</code> for <code>Category</code> instances.</p> <p>The field stats table shows all fields that were loaded from the database. Therefore, you'll generally see the primary key field (<code>id</code> in our example) in the stats even if we you don't use it in your own code because Django will automatically load the primary key.</p>"},{"location":"tutorial/use_only_or_defer/#onlydefer","title":"<code>only</code>/<code>defer</code>","text":"<p>In these situations, we can use the <code>only</code> method of QuerySets to only fetch the values we're interested in.</p> <p>Let's update our view as follows:</p> <pre><code>def books_list(request):\n    books = Book.objects.select_related(\"category\", \"author\").only(\n        \"title\",\n        \"category__name\",\n        \"author__first_name\",\n        \"author__last_name\",\n    )\n    return render(request, \"books.html\", {\"books\": books})\n</code></pre> <p>And run our profilers:</p> <pre><code>Time in ms (10 calls) - Min: 193.54, Max: 238.62, Avg: 219.09\n\nMemory - size in KiB (10 calls) - Min: 5485.70, Max: 5855.15, Avg: 5698.45\nMemory - peak in KiB (10 calls) - Min: 8448.93, Max: 8819.18, Avg: 8658.94\n</code></pre> <p>We can notice a small speed gain of around 30ms in average. However, we're now just using around 5.7MB; compared the previous 35MB we were using, it's a huge improvement - mostly explained by the fact that we're no longer loading the large <code>summary</code> and <code>biography</code> fields.</p> <p>If we go to the query view, the fields stats will now look like this:</p> <p></p> <p>You can notice that the <code>author_id</code> and <code>category_id</code> are still being loaded even if we don't use it in our code. However, they're required for the <code>select_related</code> to work. This behaviour is detailed in the defer section of QuerySets in the Django docs (linked in note above).</p>"},{"location":"tutorial/use_only_or_defer/#summary","title":"Summary","text":"<p><code>dj-tracker</code> shows all fields usage in a queryset. We can use that information to apply the <code>only</code> or <code>defer</code> optimisations when we notice that some fields aren't being used.</p> <p>I highly recommend reading the various notes on the docs of <code>only</code> and <code>defer</code> and take them into consideration when you apply these optimisations.</p> <p>Back to our query, you may (or not) have seen in the <code>Hints</code> section of the query page that <code>dj-tracker</code> suggests using <code>.values</code> or <code>.values_list</code>. Check out the next page to learn more about it.</p>"},{"location":"tutorial/use_values_or_values_list/","title":"<code>values</code>/<code>values_list</code> usage","text":"<p>When <code>dj-tracker</code> detects that no model attributes/methods, except the ones needed to build model instances, are used for all instances of a queryset; it'll hint at using the <code>.values</code> or <code>.values_list</code> methods.</p> <p>In our example, we're only using raw model fields, namely <code>title</code>, <code>category.name</code>, <code>author.first_name</code> and <code>author.last_name</code>; we aren't using any method or such. Therefore it's a candidate for the <code>Use values/values_list</code> hint:</p> <p></p>"},{"location":"tutorial/use_values_or_values_list/#view-template","title":"View - Template","text":"<p>Let's update our view to use <code>.values</code>:</p> <pre><code>def books_list(request):\n    books = Book.objects.values(\n        \"title\",\n        \"category__name\",\n        \"author__first_name\",\n        \"author__last_name\",\n    )\n    return render(request, \"books.html\", {\"books\": books})\n</code></pre> <p>Django will only fetch the fields we passed in to the <code>.values</code> method, so we can remove the <code>.only</code> call as it's redundant. See docs on the <code>.values</code> method.</p> <p>Our query will now return dictionary objects instead of model instances. An instance will have the following structure:</p> <pre><code>{\n    \"title\": \"Harry Potter\",\n    \"category__name\": \"Science Fiction\",\n    \"author__first_name\": \"Joanne\",\n    \"author__last_name\": \"Rowling\"\n}\n</code></pre> <p>Let's update our template to match this new structure:</p> <pre><code>{% for book in books %}\n&lt;h4&gt;{{ book.title }}&lt;/h4&gt;\n&lt;dl&gt;\n  &lt;dt&gt;Author&lt;/dt&gt;\n  &lt;dd&gt;{{ book.author__first_name }} {{ book.author__last_name }}&lt;/dd&gt;\n\n  &lt;dt&gt;Category&lt;/dt&gt;\n  &lt;dd&gt;{{ book.category__name }}&lt;/dd&gt;\n&lt;/dl&gt;\n{% endfor %}\n</code></pre>"},{"location":"tutorial/use_values_or_values_list/#profile","title":"Profile","text":"<p>Let's now run our profilers to see how our view performs:</p> <pre><code>Time in ms (10 calls) - Min: 86.58, Max: 115.77, Avg: 96.92\n\nMemory - size in KiB (10 calls) - Min: 2303.49, Max: 2580.66, Avg: 2431.73\nMemory - peak in KiB (10 calls) - Min: 5262.68, Max: 5544.66, Avg: 5392.42\n</code></pre> <p>Our new version is in average 2x faster (previous average was 219ms) and uses 2.5x less memory as well.</p> <p>This can be explained by the fact that creating and manipulating dictionaries is cheaper than doing the same with model instances - both in speed and in memory terms.</p> <p>This is now what the field stats for our query look like:</p> <p></p>"},{"location":"tutorial/use_values_or_values_list/#summary","title":"Summary","text":"<p><code>dj-tracker</code> keeps track of every model atribute/method access to provide hints on when to use the <code>.values</code> or <code>.values_list</code> optimisations.</p> <p>Another valuable optimisation method that <code>dj-tracker</code> can give hints about is the <code>.iterator</code> method. Check out the next steps for more on this.</p>"}]}